* Add two new sections near the top: Data Collection Philosophy and State File Structure & Architecture

* Make the four-layer stack, data directories, and project structure explicit and unambiguous

* Expand System Design Principles to cover orchestrator/tool pattern and module independence

* Preserve existing PRD content and tone; integrate changes without altering scope

* Keep the document clear, explainable, and privacy-forward

# AI Chief of Staff - Contextual Coordination System (Enhanced PRD)

### TL;DR

A deterministic personal assistant that maintains organizational context, tracks informal commitments, and coordinates action for remote leadership teams. It collects Slack, Calendar, and Drive activity into transparent JSON, extracts goals and commitments, generates briefings, and assists with scheduling—delivering persistent memory and gentle accountability for executives.

---

## Data Collection Philosophy

* Comprehensive: Collect all relevant Slack, Calendar, and Drive data required for context, commitments, and scheduling coverage.

* Immutable: Never overwrite. Use append-only logs to ensure complete auditability and reproducible processing.

* Local-First: Store and process on a secure local system by default; no cloud usage until explicitly enabled.

* Structured: Use JSONL for raw, time-ordered logs and structured JSON for state and processed views.

* Explainable: Every derived insight links back to its raw source with file path and record index.

---

## State File Structure & Architecture

### Four-Layer Stack

* Layer 4: Interface

  * Surfaces: Dashboard, Slack bot, daily/weekly briefings, CLI

* Layer 3: Intelligence (LLM)

  * Capabilities: Commitment extraction, summarization, context generation, scheduling intent detection

* Layer 2: Processing (Deterministic)

  * Capabilities: Relevance scoring, deduplication, change detection, anomaly detection

* Layer 1: Collection (Deterministic)

  * Sources: Slack, Calendar, Drive

  * Guarantees: Continuous, complete capture; never overwrites; append-only

### Data Directories (local, gitignored)

* data/

  * raw/

    * slack/

      * YYYY-MM-DD/

        * channels.json (channel list with metadata)

        * messages\_\*.jsonl (messages by channel/thread)

        * users.json (user directory snapshot)

    * calendar/

      * YYYY-MM-DD/

        * events\_\*.json (events by person or scope)

    * drive/

      * YYYY-MM-DD/

        * changes\_\*.json (metadata-only changes in MVP)

    * employees/

      * roster.json (master employee list: Slack ID, email, calendar ID)

  * processed/

    * goals.json

    * commitments.jsonl

    * digests/

    * coverage_stats.json

  * state/

    * cursors.json

    * last_run.json

    * ids.json

  * logs/

    * collector_runs.jsonl

    * orchestrator.jsonl

    * errors.jsonl

### Project Structure (in repo)

* ai-cos-lab/

  * .git/

  * .gitignore (excludes data/, logs/, .env, caches)

  * README.md (project overview & setup)

  * DEVELOPMENT_LOG.md (daily progress tracking)

  * ARCHITECTURE.md (system design decisions)

  * requirements.txt (Python dependencies)

  * .env.example (template for credentials)

  * Makefile (common commands)

  * src/

    * core/

      * **init**.py

      * config.py (configuration management)

      * state.py (state persistence)

    * collectors/

      * **init**.py

      * base.py (base collector class)

      * slack.py (Slack collector)

      * calendar.py (Calendar collector)

      * drive.py (Drive collector)

    * processors/

      * **init**.py

      * goals.py (goal tracking)

      * commitments.py (commitment extraction)

      * profiles.py (person profiles)

    * orchestrators/

      * **init**.py

      * scheduler.py (meeting scheduler)

      * briefing.py (digest generator)

    * interfaces/

      * **init**.py

      * cli.py (CLI commands)

      * slack_bot.py (Slack interface)

      * dashboard.py (web dashboard)

  * tools/ (Claude Code callable tools)

    * collect_data.py (run data collection)

    * update_goals.py (modify goals)

    * find_slots.py (find meeting times)

    * generate_digest.py (create briefing)

  * tests/

    * test_collectors.py

    * test_processors.py

    * fixtures/

  * scripts/

    * setup.sh (initial setup)

    * run_collection.sh (manual collection)

    * clean_data.sh (data cleanup)

  * data/ (not in git; see Data Directories)

---

## Goals

### Business Goals

* Achieve daily usage of the goal tracking system by primary user for 14 consecutive days.

* Reduce executive “hunting for context” time from 30–60 minutes to ≤10 minutes per day within 4 weeks.

* Surface and track ≥80% of explicit meeting commitments across Slack and meetings.

* Propose and facilitate acceptance of ≥3 meetings per week via the scheduler.

* Maintain local-only data storage with full audit trails to build trust and accelerate adoption.

### User Goals

* Single source of truth for goals, commitments, and context across Slack, Calendar, and Drive.

* Fast daily briefings that highlight what’s changed, what’s due, and what needs attention.

* Lightweight scheduling via Slack with human approval and minimal back-and-forth.

* Gentle accountability: timely nudges and summaries without micromanagement.

* Clear visibility into who promised what, when, and where it came from.

### Non-Goals

* Complex UI: no advanced web app in the MVP (Slack and simple dashboard only).

* External scheduling or automatic rescheduling in MVP (internal only; human-approved).

* Real-time streaming or ML training pipelines; batch processing suffices initially.

---

## User Stories

* Chief Business Officer (Primary: David)

  * As a CBO, I want a daily briefing that summarizes goals, commitments, and changes, so that I can prioritize my day in minutes.

  * As a CBO, I want to ask for meeting options in Slack, so that I can coordinate quickly without opening calendars.

  * As a CBO, I want to see who committed to what and when, so that I can follow up confidently.

  * As a CBO, I want to update goal statuses via Slack, so that I keep everything current with minimal friction.

* Executive (Secondary)

  * As an executive, I want reminders of my commitments, so that I follow through on what I promised.

  * As an executive, I want a weekly summary of my activity and goals, so that I can course-correct.

* Executive Assistant / Chief of Staff

  * As an EA, I want to review proposed meeting slots before booking, so that I avoid conflicts and maintain preferences.

  * As an EA, I want to update goals and ownership, so that the briefings reflect reality.

* System Admin (Developer/Operator)

  * As an operator, I want deterministic collectors and transparent logs, so that I can debug and trust the data.

  * As an operator, I want explicit data deletion and access revocation flows, so that I can honor privacy requests.

---

## Functional Requirements

* Collection (Priority: P0)

  * SlackCollector: capture all channels, DMs, threads on a schedule (15–30 min), including metadata and users.

  * CalendarCollector: capture all internal calendars hourly with attendees and event metadata.

  * DriveCollector: capture document activity and changes every 2 hours (metadata-only in MVP).

  * EmployeeCollector: build a roster mapping Slack IDs, emails, and calendar IDs.

* Processing (Priority: P0)

  * Deduplication and change detection for collected items.

  * Relevance scoring for goals/commitments and key changes.

  * Commitment extraction from Slack and meeting notes (LLM-assisted).

  * Goal tracking state machine with history and ownership.

* Briefings (Priority: P0)

  * Daily briefing digest with goals, commitments, changes, and nudges (CLI/Slack).

  * Weekly Slack summary with highlights and risk alerts.

* Scheduling (Priority: P1)

  * Detect scheduling intents from Slack commands or messages.

  * Find common slots across internal attendees; propose top 3 options.

  * Human approval workflow and event booking via calendar API.

* Slack Interface (Priority: P1)

  * Commands: /cos goals, /cos update status:, /cos schedule @user , /cos digest, /cos feedback .

  * Interactive message blocks for slot selection and approval.

* Dashboard (Priority: P2)

  * Simple HTML views: coverage stats, goals, commitment ledger, activity heatmap.

  * Read-only transparency; links to raw references.

* Feedback & Trust (Priority: P1)

  * /cos feedback command to capture issues and suggestions with context.

  * Inline “Why am I seeing this?” links that show source and reasoning.

* Admin & Privacy (Priority: P0)

  * Local storage only (gitignored).

  * Data deletion and access revocation workflows.

  * Comprehensive logging and audit trails.

---

## User Experience

Entry Point & First-Time User Experience

* Discovery: The bot is introduced in a leadership Slack channel with a short demo and clear benefits (context, accountability, scheduling).

* Developer onboarding:

  * Clone repo, create virtual environment, configure .env, run make setup, run collectors locally, verify data directories and logs.

  * Install Slack app with required scopes; connect Google APIs via OAuth for Calendar and Drive (readonly in MVP).

* Executive onboarding:

  * Invite the bot to relevant Slack channels/DMs.

  * Approve calendar and Drive read-only scopes (guided by operator).

  * Seed 5–10 initial goals via /cos goals add or CLI to kickstart daily value.

  * Trigger first digest via /cos digest or scheduled time (morning).

Core Experience

* Step 1: Morning briefing in Slack (daily)

  * UX: One concise message with sections: Changes, Goals, Commitments, Upcoming Meetings, Nudges.

  * Handling: Show only high-signal updates; include “Why?” links and raw references.

  * Success: Quick scan, clear actions; buttons: View Goals, Review Commitments, Schedule.

* Step 2: Update goals and commitments

  * UX: /cos goals shows active items with status chips; inline actions to mark completed or change owner/due date.

  * Handling: Validate goal IDs; confirm changes; track history with timestamps.

  * Success: Fast updates; immediate confirmation and digest refresh.

* Step 3: Schedule meetings via Slack

  * UX: /cos schedule @alice 30min → bot posts 3 best options with a “Propose” and “Book with Approval” flow.

  * Handling: Timezone awareness, working hours, hold tentative slots only after human approval.

  * Success: Selected option booked; confirmation posted with calendar link.

* Step 4: Gentle accountability

  * UX: Soft nudges for near-due commitments and stale goals (e.g., “2 days until due”).

  * Handling: Respect user preferences; snooze and “not now” options.

  * Success: Increased follow-through without annoyance.

* Step 5: Weekly summary (Fridays)

  * UX: Highlights of progress, slips, notable changes, and next week’s prep.

  * Handling: Offer “acknowledge” and “create follow-up goal.”

  * Success: Closes the loop and sets up the next week.

Advanced Features & Edge Cases

* Power-user commands: bulk goal updates, tagging, assign/delegate.

* Ambiguous commands: bot clarifies with disambiguation prompts (e.g., multiple users or goals).

* Scheduling conflicts: offers alternates or asks for new constraints.

* Missing data sources: bot clearly reports which integrations are incomplete and how to fix.

UI/UX Highlights

* Accessibility: high-contrast message formatting, keyboard-friendly CLI, readable dashboard.

* Transparency: every surface links to sources; show reasoning in plain language.

* Responsiveness: digest under 30s; scheduler options under 10s.

* Respectful nudging: configurable cadence, opt-out for certain channels.

---

## Narrative

David, a Chief Business Officer leading a remote team, starts each day sifting through Slack threads, calendar invites, and scattered documents to reconstruct context. What was promised in the product sync? Which goals are blocked? Who owes what by Friday? The cognitive overhead costs him an hour, and still, things slip through the cracks.

With the AI Chief of Staff, David opens Slack to a concise morning brief. It highlights changes since yesterday, today’s priorities, and upcoming deadlines. A “Why?” link shows exactly where each insight came from—DMs, channels, calendar, or Drive—building trust through transparency. When he needs to align quickly with Engineering and Sales, he types “/cos schedule @jane @alex 30min.” The bot proposes three conflict-free slots based on their calendars. David confirms and the invites go out.

Throughout the week, commitments made in meetings and Slack are captured and tracked. Gentle nudges surface near-due items, and a Friday summary shows progress, risks, and suggested follow-ups. No more hunting for context; no more dropped balls. The result: faster decisions, clearer accountability, and reclaimed time—measurable improvements for the business and a calmer workday for David and his peers.

---

## Success Metrics

* Core KPIs

  * Daily adoption: primary user uses the goal system for 14 consecutive days.

  * Context time: reduce to ≤10 minutes/day within 4 weeks.

  * Follow-through: ≥80% of meeting commitments tracked and surfaced.

  * Scheduling: ≥3 meetings/week proposed and accepted via the system.

  * Trust: 100% of surfaced items have accessible sources and explainability.

### User-Centric Metrics

* Daily active users (executives) engaging with digest or commands.

* Goal updates per week and commitment acknowledgments.

* Nudge response rate and snooze/opt-out rates.

* User satisfaction via quick 2-question Slack pulse (usefulness, clarity).

### Business Metrics

* Time saved per executive per day (self-reported and observed).

* Meetings coordinated per week without manual back-and-forth.

* Reduction in missed commitments or rescheduled meetings.

### Technical Metrics

* Data collection lag: ≤5 minutes Slack; ≤60 minutes Calendar; ≤120 minutes Drive.

* Digest generation: ≤30 seconds; scheduling proposals: ≤10 seconds.

* Error rate: <1% failed runs per day with automatic retries.

* Uptime of scheduled jobs: ≥99% during business hours.

### Tracking Plan

* Events: collector_run_started/completed, messages_collected, events_collected, drive_changes_collected.

* Processing: commitments_extracted, goals_updated, digest_generated, digest_delivered.

* User actions: command_invoked, goal_status_changed, commitment_acknowledged, schedule_requested, slots_proposed, slot_booked, feedback_submitted.

* Errors: api_rate_limited, auth_failed, parse_failed, duplicate_detected, deletion_request_processed.

---

## Technical Considerations

### Technical Needs

* Components:

  * Collectors: Slack, Calendar, Drive, Employee roster.

  * Processing: deduplication, change detection, relevance scoring, commitments extraction, goals.

  * Orchestrators: scheduler (meetings), briefing (digests).

  * Interfaces: CLI, Slack bot, simple dashboard (read-only).

* Determinism and transparency:

  * Tools execute and produce structured JSON; orchestrator calls tools only.

  * No direct mutations by the LLM; all state persisted in append-only JSONL.

* Configuration:

  * Environment-driven (.env), explicit state in data/state, comprehensive logs.

### Integration Points

* Slack: bot token with channel/DM read scopes, events subscription, slash commands.

* Google Calendar: OAuth2 (calendar.readonly + write for booking), domain-wide delegation optional.

* Google Drive: OAuth2 (drive.metadata.readonly for MVP).

* Optional future: Email, transcription tools (Otter, Gong), Teams.

### Data Storage & Privacy

* Local-only storage (gitignored). Directory sketch:

  * data/raw/slack/YYYY-MM-DD: channels.json, messages\_\*.jsonl, users.json.

  * data/raw/calendar/YYYY-MM-DD: events\_\*.json.

  * data/raw/drive/YYYY-MM-DD: changes\_\*.json.

  * data/processed: summaries, interaction logs, commitment ledger, goals.

  * data/state: IDs, cursors, last-run timestamps.

  * data/logs: execution logs with timestamps and outcomes.

* Privacy safeguards:

  * Read-only access where possible; write only for booking when explicitly approved.

  * Full audit trail: each surfaced item links to raw_reference and processing steps.

  * Data deletion: selective purge by person, channel, or time range; rebuild processed artifacts accordingly.

  * Access revocation: remove tokens, purge associated data, confirm in Slack and logs.

### Scalability & Performance

* Expected load: 3–10 executives; org Slack with dozens of channels.

* Batch schedule with staggered intervals to respect rate limits.

* Incremental processing keyed by timestamps and cursors.

* Storage: append-only JSONL; periodic compaction tasks for processed views.

### Potential Challenges

* API rate limits: exponential backoff, jitter, and adaptive polling.

* Ambiguity in natural language commitments: conservative extraction with human confirmation.

* Timezone complexity: normalize to UTC; show user-local times in surfaces.

* Trust and adoption: emphasize explainability and human approval in all actions.

### Edge Cases & Error Handling

* Collector failures

  * Slack outage or 429s: backoff with capped retries; skip window recorded; alert in Slack to operator.

  * Calendar/Drive auth expired: fail fast, prompt re-auth, pause dependent features.

  * Partial data: mark digest sections as “partial” with reason and remediation link.

* Ambiguous goal updates

  * Multiple matches: bot returns a disambiguation list with concise context.

  * Invalid status or date: validate and suggest closest valid value; require confirmation.

* Scheduling edge cases

  * No mutual availability: suggest widening time window, alternate durations, or async option.

  * Attendee preferences: respect working hours; ask for overrides explicitly.

* Data deletion or access revocation

  * On request: queue purge job; remove raw and processed references; log immutable tombstone.

  * Rebuild derived artifacts (digests, ledgers) without deleted data; note redactions in audit view.

---

## Development Environment & Workflow

### Project Structure (in repo)

* Root

  * .git, .gitignore (excludes data/, logs/, .env, pyc, cache, OS files, local DBs)

  * README.md (overview & setup), DEVELOPMENT_LOG.md (daily progress), ARCHITECTURE.md (design)

  * requirements.txt, .env.example, Makefile

* src

  * core (config, state)

  * collectors (base, slack, calendar, drive)

  * processors (goals, commitments, profiles)

  * orchestrators (scheduler, briefing)

  * interfaces (cli, slack_bot, dashboard)

* tools (collect_data, update_goals, find_slots, generate_digest)

* tests (unit tests for collectors/processors; fixtures)

* scripts (setup, run_collection, clean_data)

* data (gitignored): raw, processed, state, logs

### Daily Development Workflow

* Start of day: run make status; update DEVELOPMENT_LOG.md with today’s goals (make plan).

* Development loop: run focused tests (e.g., make test-module M=collectors.slack), run locally (make run-local), lint (make lint).

* End of day: commit with message (make commit MSG="..."); append progress and issues (make log).

### Git Strategy

* Main branch: stable; feature branches per module.

* Frequent small commits with descriptive messages.

* Never commit data/ or secrets; use .env and .env.example pattern.

* Pull requests optional for solo; still write concise summaries.

### Clean Code Principles

* Self-contained modules with clear inputs/outputs.

* Idempotent tools safe for repeated runs.

* Explicit state under data/state; no hidden side effects.

* Comprehensive logs; traceability from source to surface.

* Write tests before features or immediately after scaffolding.

### Onboarding

* Developer/operator

  * Install Python 3.10+, create virtualenv, pip install -r requirements.txt.

  * Copy .env.example to .env; fill Slack and Google credentials.

  * Run scripts/setup; verify data/ directories created.

  * make run-local; ensure collectors run and logs show success.

* Executive user

  * Confirm bot installed in Slack; invite to relevant channels/DMs.

  * Approve calendar/Drive readonly scopes if prompted.

  * Seed initial goals using /cos goals add or via CLI with operator’s help.

  * Trigger /cos digest; confirm daily schedule time.

---

## Core Architecture & System Design

### System Design Principles

* Claude Code as Orchestrator Only

  * The LLM orchestrates by invoking tools via safe subprocess calls.

  * It never reads or writes data stores directly.

  * All tool outputs are structured JSON; the orchestrator reasons over these outputs and decides next steps.

* Tool Pattern (deterministic, composable)

  * Inputs: flags or environment variables; no hidden state.

  * Execution: tool runs to completion; prints a single JSON object to stdout; uses exit codes for success/failure.

  * Outputs: status, counters (e.g., slack_messages, calendar_events), paths to artifacts, and any warnings.

  * Example behavior: a collect_data tool returns status=success and counts of items collected across sources; orchestrator logs the result and schedules processing.

* Module Independence

  * Each module (collector, processor, interface) can run standalone.

  * Modules communicate via files (JSON/JSONL) under data/; no shared memory.

  * Contracts: clearly defined input and output schemas; versioned if needed.

  * Fail-open for non-critical paths: partial results are accepted and marked; system remains operable.

* Deterministic-First, LLM-Assist

  * Collection and processing are deterministic and reproducible.

  * LLMs are used for text understanding (e.g., commitment extraction, summarization), never for direct state mutation.

* Explainability & Traceability

  * Every surfaced item links to raw_reference (file path and record index) and lists the processing steps taken.

### Four-layer stack

* Layer 1: Collection (deterministic). All Slack, Calendar, Drive. Complete, continuous, append-only.

* Layer 2: Processing (deterministic). Relevance scoring, deduplication, change detection, anomaly detection.

* Layer 3: Intelligence (LLM). Commitment extraction, summarization, context generation, scheduling intent detection.

* Layer 4: Interface. Slack bot, daily/weekly briefings, simple dashboard, CLI.

### Extensibility

* New data sources: add collector module, define schema, schedule, and storage path; register in processing pipeline.

* New interfaces: add adapter (e.g., email or Teams); reuse processing and orchestration layers.

* Configuration-driven: enable/disable modules via config; minimal code changes.

---

## MVP Feature Set & Implementation Plan

* Week 1: Foundation

  * Deliverables: Slack/Calendar/Drive collectors, employee roster, goal tracker, first daily digest.

  * Proof: data/ populated; /cos digest posts; 5+ goals tracked.

* Week 2: Scheduling (internal only)

  * Deliverables: slot finder, availability merger with TZ handling, Slack proposal flow, human approval booking.

  * Proof: 3+ meeting proposals; ≥1 booked with approval.

* Week 3: Slack Bot Interface

  * Deliverables: /cos goals, /cos update, /cos schedule, /cos digest, /cos feedback; event handling and permissions.

  * Proof: Commands respond reliably; digests and updates via Slack.

* Week 4: Integration & Polish

  * Deliverables: simple dashboard, end-to-end tests, robust error handling, documentation, cron jobs for batch runs.

  * Proof: Daily use; 10+ goals tracked; 5+ meetings scheduled; saving 30+ minutes/day.

Feedback Mechanism

* /cos feedback captures user input, attaches context (last command, digest ID), and stores in data/processed/feedback.jsonl. Weekly review included in Friday summary.

---

## Data Architecture & Privacy

* Core data structures

  * Employee roster: email, Slack ID, calendar ID, title, department, manager, profile traits.

  * Interaction log: timestamped records across Slack, calendar, and Drive; summaries and raw references.

  * Commitment ledger: ID, from/to, description, due, source, status, created/updated timestamps.

  * Goal state machine: id, title, owner, delegated_to, status, created/due/completed, history.

* Local storage and audit

  * Append-only raw JSONL with timestamps; processed artifacts regenerate from raw.

  * Every surfaced item cites raw_reference (file:path:line/index).

  * Logs include tool invocation, parameters, duration, and outcomes.

* Privacy, deletion, and revocation

  * Read-only by default; booking requires explicit write scope with human approval.

  * Deletion workflow: filter and purge by subject/time/source; reprocess derived artifacts; keep tombstone record.

  * Access revocation: remove tokens, confirm via Slack notice, disable related features gracefully.

---

## Critical Design Decisions & Risk Mitigation

* Design decisions

  * Data-first before intelligence.

  * Tools execute; orchestrator coordinates; LLMs assist interpretation only.

  * JSON for all state; human-readable, diffable, auditable.

  * Modular design; each feature shippable independently.

  * Human approval for any action with external effects.

  * Local-first deployment for trust and speed.

* Explicitly out of scope (MVP)

  * Complex web UI, real-time streaming, external scheduling, auto-rescheduling, ML training, cloud deployment.

* Risks and mitigations

  * Technical: API rate limits and outages → backoff, retries, partial digests with clear notices.

  * Adoption: friction or distrust → explainability, visible sources, opt-in nudges, immediate value in Week 1.

  * Privacy: sensitive data handling → local-only storage, deletion/revocation workflows, least-privilege scopes.

---

## Milestones & Sequencing

### Project Estimate

* Medium: \~4 weeks to MVP; Ideal-state features in 8–12 weeks.

### Team Size & Composition

* Small team: 1–2 people moving fast.

  * Product/Operator (David): defines goals, validates UX, drives adoption.

  * Builder (can be same person): implements collectors, processing, Slack bot, scheduler.

### Suggested Phases

* Phase 1: Foundation (Week 1)

  * Key Deliverables: collectors running, goal tracker, daily digest. Owner: Builder.

  * Dependencies: Slack app installed; Google OAuth credentials configured.

* Phase 2: Scheduler (Week 2)

  * Key Deliverables: slot finder, Slack proposals, approval-based booking. Owner: Builder.

  * Dependencies: Calendar write scope (with approval).

* Phase 3: Slack Bot (Week 3)

  * Key Deliverables: commands for goals, updates, scheduling, digest, feedback. Owner: Builder.

  * Dependencies: Slack events and interactivity configured.

* Phase 4: Polish & Launch (Week 4)

  * Key Deliverables: dashboard, tests, error handling, documentation, cron jobs. Owner: Builder.

  * Dependencies: Stable collectors and processing.

### “Smart Amateur” Step-by-Step Roadmap (Hands-On Guide)

* Day 0: Prep

  * Create a clean workspace; install Python 3.10+; set up GitHub repo; install VS Code or preferred IDE.

* Day 1: Repo & Environment

  * Clone template; create virtualenv; pip install requirements; copy .env.example to .env; fill Slack and Google placeholders.

  * Run scripts/setup; verify data/ directories created; commit initial scaffold.

* Day 2: Slack Collector

  * Create Slack app; enable necessary scopes; install to workspace; get bot token.

  * Implement SlackCollector; run make run-local; confirm data/raw/slack populated; add logs; write first unit test.

* Day 3: Calendar Collector

  * Enable Google Calendar API; complete OAuth; store tokens securely.

  * Run CalendarCollector hourly (manual first); verify events collected; log counts and last sync time.

* Day 4: Drive Collector + Employee Roster

  * Enable Drive API (metadata readonly); collect recent changes; build employees roster from Slack users and calendar attendees.

  * Sanity-check data completeness; fix pagination/rate limits if needed.

* Day 5: Goals + First Digest

  * Implement goal state machine and CLI; create 5–10 goals for yourself; write to data/processed/goals.json.

  * Implement digest generator; run /cos digest (or CLI); post to Slack; capture feedback via /cos feedback.

* Day 6: Scheduling Slot Finder

  * Implement find_common_slots; handle timezones; respect working hours; generate top 3 options.

  * Test with two calendars; log conflicts and gaps; iterate until proposals look sensible.

* Day 7: Slack Command Wiring

  * Implement /cos goals, /cos update, /cos schedule, /cos digest, /cos feedback.

  * Add interactivity (buttons/selects) for slot approval; handle errors with friendly messages.

* Day 8: Commitment Extraction (LLM-assisted)

  * Parse recent Slack messages; extract “who promised what by when”; store in commitment ledger; link raw_reference.

  * Surface pending commitments in daily digest; add acknowledge/snooze actions.

* Day 9: Dashboard (Simple)

  * Build static HTML pages showing: coverage stats, goals, commitments, heatmap; link to sources.

  * Host locally; add link in Slack digest.

* Day 10: Hardening & Launch

  * Write end-to-end tests; add retries/backoff; schedule cron jobs; document setup in README.

  * Announce to small exec group; run daily for a week; collect /cos feedback; iterate.

Weekly Operating Rhythm (Post-Launch)

* Monday: verify collectors; review goals; set week priorities.

* Daily: read digest; update goals; schedule as needed.

* Friday: review weekly summary; process feedback; plan improvements.

---

## Appendix: Technical Specifications

* API Requirements

  * Slack: bot token with channels:history, groups:history, im:history, mpim:history, users:read, channels:read, chat:write, commands, app_mentions:read, reactions:read (adjust minimally).

  * Google Calendar: OAuth2 calendar.readonly; calendar.events.write for approved bookings.

  * Google Drive: OAuth2 drive.metadata.readonly (MVP).

* System Requirements

  * Python 3.10+; 10GB free disk for data; cron or task scheduler.

  * LLM API access for summarization/commitment extraction.

  * Slack workspace admin privileges for app installation.

* Performance Targets

  * Collection lag: Slack ≤5 min; Calendar ≤60 min; Drive ≤120 min.

  * Digest generation ≤30s; scheduling proposals ≤10s.

  * Error rate <1% daily runs; automatic retries and alerts.

* Extensibility Note

  * To add a new data source: create collector module, define JSON schema, schedule polling, update processing to recognize new records, and add surfaces as needed.

  * To add a new interface: create adapter (e.g., email notifications), reuse orchestration; no changes to collectors required.

* Contact & Support

  * Product Owner: David Campos, Chief Business Officer.

  * Development Approach: Solo with AI assistance.

  * Support: Open GitHub issues for bugs/feature requests; use /cos feedback for in-app reports.