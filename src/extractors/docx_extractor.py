#!/usr/bin/env python3
"""
DOCX Content Extractor - Google Docs Meeting Notes Processing
Extracts structured content from .docx files generated by Google Meet/Gemini

This module handles Google Docs meeting notes that are exported as .docx files,
preserving document structure and extracting meeting metadata.

Architecture:
- Uses python-docx library for reliable DOCX parsing
- Preserves document structure (headings, paragraphs, lists)
- Extracts meeting metadata from filename and content
- Integrates with StructuredExtractor for action item detection
- Optimized for Google Meet/Gemini generated documents

Usage:
    from src.extractors.docx_extractor import DocxContentExtractor
    extractor = DocxContentExtractor()
    content = extractor.extract_content("meeting_notes.docx")
"""

import logging
import os
import re
import locale
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass

# Set locale to handle datetime parsing issues
try:
    locale.setlocale(locale.LC_ALL, 'en_US.UTF-8')
except:
    try:
        locale.setlocale(locale.LC_ALL, 'C')
    except:
        pass

try:
    from docx import Document
    from docx.document import Document as DocumentType
    from docx.text.paragraph import Paragraph
    from docx.table import Table
    DOCX_AVAILABLE = True
except ImportError:
    print("Warning: python-docx not installed. Install with: pip install python-docx")
    Document = None
    DocumentType = None
    DOCX_AVAILABLE = False

logger = logging.getLogger(__name__)


@dataclass
class ExtractedDocument:
    """Structured representation of extracted DOCX content"""
    filename: str
    title: str
    content: str
    structured_content: Dict[str, Any]
    meeting_metadata: Dict[str, Any]
    confidence_score: float
    extraction_stats: Dict[str, int]


class DocxExtractionError(Exception):
    """Raised when DOCX extraction fails"""
    pass


class DocxContentExtractor:
    """
    High-performance DOCX content extraction for Google Meet/Gemini notes
    
    Features:
    - Google Docs structure-aware parsing
    - Meeting metadata extraction from filename and content
    - Preserved document formatting for StructuredExtractor compatibility
    - Performance optimized for meeting note documents (2-5MB)
    - Robust error handling for corrupted or protected documents
    """
    
    def __init__(self, preserve_structure: bool = True):
        """
        Initialize DOCX content extractor
        
        Args:
            preserve_structure: Whether to preserve document structure in output
        """
        self.preserve_structure = preserve_structure
        self.logger = logging.getLogger(f"{__name__}.DocxContentExtractor")
        
        # Compile patterns for meeting notes detection
        self._compile_patterns()
        
        # Statistics tracking
        self.stats = {
            'documents_processed': 0,
            'successful_extractions': 0,
            'failed_extractions': 0,
            'total_paragraphs': 0,
            'total_characters': 0
        }
    
    def _compile_patterns(self):
        """Compile regex patterns for content analysis"""
        
        # Google Docs meeting notes filename patterns
        self.meeting_notes_patterns = [
            re.compile(r'^(.+?)\s*-\s*\d{4}_\d{2}_\d{2}.*Notes by Gemini\.docx$', re.IGNORECASE),
            re.compile(r'^Meeting started \d{4}_\d{2}_\d{2}.*Notes by Gemini\.docx$', re.IGNORECASE),
            re.compile(r'^(.+?)\s*-.*PDT.*Notes by Gemini\.docx$', re.IGNORECASE)
        ]
        
        # Document section patterns
        self.section_patterns = {
            'summary': re.compile(r'^(Summary|Overview|Meeting Summary)', re.IGNORECASE),
            'action_items': re.compile(r'^(Action Items?|Next Steps?|Follow[- ]?ups?|Tasks?)', re.IGNORECASE),
            'participants': re.compile(r'^(Participants?|Attendees?|Present)', re.IGNORECASE),
            'agenda': re.compile(r'^(Agenda|Topics?|Discussion)', re.IGNORECASE),
            'decisions': re.compile(r'^(Decisions?|Conclusions?|Outcomes?)', re.IGNORECASE)
        }
        
        # Meeting metadata patterns
        self.datetime_patterns = [
            re.compile(r'(\d{4}_\d{2}_\d{2})\s+(\d{2}_\d{2})\s+(PDT|PST|EST|EDT)'),
            re.compile(r'(\d{4}-\d{2}-\d{2})\s+(\d{2}:\d{2})'),
            re.compile(r'(January|February|March|April|May|June|July|August|September|October|November|December)\s+\d{1,2},\s+\d{4}', re.IGNORECASE)
        ]
    
    def extract_content(self, file_path: str) -> ExtractedDocument:
        """
        Extract content from DOCX file
        
        Args:
            file_path: Path to .docx file
            
        Returns:
            ExtractedDocument with extracted content and metadata
        """
        self.logger.debug(f"Extracting content from: {file_path}")
        
        if not os.path.exists(file_path):
            raise DocxExtractionError(f"File not found: {file_path}")
        
        if not file_path.lower().endswith('.docx'):
            raise DocxExtractionError(f"File must be .docx format: {file_path}")
        
        if Document is None:
            raise DocxExtractionError("python-docx not installed. Cannot extract DOCX content.")
        
        try:
            # Load document
            doc = Document(file_path)
            
            # Extract filename metadata
            filename = os.path.basename(file_path)
            filename_metadata = self._extract_filename_metadata(filename)
            
            # Extract document content
            content_data = self._extract_document_content(doc)
            
            # Extract content-based metadata
            content_metadata = self._extract_content_metadata(content_data['text'])
            
            # Merge metadata
            meeting_metadata = {**filename_metadata, **content_metadata}
            
            # Calculate confidence score
            confidence = self._calculate_confidence_score(
                content_data, filename_metadata, content_metadata
            )
            
            # Create result
            result = ExtractedDocument(
                filename=filename,
                title=meeting_metadata.get('title', filename_metadata.get('title', '')),
                content=content_data['text'],
                structured_content=content_data['structured'],
                meeting_metadata=meeting_metadata,
                confidence_score=confidence,
                extraction_stats=content_data['stats']
            )
            
            # Update statistics
            self.stats['documents_processed'] += 1
            self.stats['successful_extractions'] += 1
            self.stats['total_paragraphs'] += content_data['stats']['paragraph_count']
            self.stats['total_characters'] += len(content_data['text'])
            
            self.logger.info(f"Successfully extracted content from: {filename}")
            return result
            
        except Exception as e:
            self.stats['documents_processed'] += 1
            self.stats['failed_extractions'] += 1
            self.logger.error(f"Failed to extract content from {file_path}: {e}")
            raise DocxExtractionError(f"DOCX extraction failed: {e}")
    
    def _extract_filename_metadata(self, filename: str) -> Dict[str, Any]:
        """
        Extract meeting metadata from filename
        
        Args:
            filename: Name of the .docx file
            
        Returns:
            Dictionary with extracted metadata
        """
        metadata = {
            'title': '',
            'date': None,
            'time': None,
            'timezone': None,
            'participants': []
        }
        
        # Try each filename pattern
        for pattern in self.meeting_notes_patterns:
            match = pattern.match(filename)
            if match:
                if match.groups():
                    raw_title = match.group(1).strip()
                    
                    # Extract participants from raw title before cleaning (if formatted as "Person1 _ Person2")
                    if ' _ ' in raw_title:
                        # Split on ' _ ' and check for participant pattern
                        parts = raw_title.split(' _ ')
                        if len(parts) >= 2:
                            first_part = parts[0].strip()
                            # Extract just the name from second part (before any " - " pattern)
                            second_part = parts[1].strip()
                            if ' - ' in second_part:
                                second_part = second_part.split(' - ')[0].strip()
                            
                            # Both should be reasonable name lengths and not empty
                            if (len(first_part) > 1 and len(first_part) < 25 and 
                                len(second_part) > 1 and len(second_part) < 25):
                                metadata['participants'] = [first_part, second_part]
                    
                    # Clean up title formatting for display
                    title = re.sub(r'[_]+', ' ', raw_title)  # Replace underscores
                    title = re.sub(r'\s+', ' ', title)   # Normalize whitespace
                    metadata['title'] = title
                break
        
        # Extract date/time information
        for pattern in self.datetime_patterns:
            match = pattern.search(filename)
            if match:
                if '_' in match.group(1):  # Format: 2025_07_25 07_29 PDT
                    date_str = match.group(1).replace('_', '-')
                    time_str = match.group(2).replace('_', ':') if len(match.groups()) > 1 else None
                    timezone = match.group(3) if len(match.groups()) > 2 else None
                    
                    try:
                        date_obj = datetime.strptime(date_str, '%Y-%m-%d').date()
                        metadata['date'] = date_obj
                        metadata['time'] = time_str
                        metadata['timezone'] = timezone
                    except ValueError:
                        pass
                break
        
        return metadata
    
    def _extract_document_content(self, doc: Any) -> Dict[str, Any]:
        """
        Extract content from DOCX document preserving structure
        
        Args:
            doc: python-docx Document object
            
        Returns:
            Dictionary with text, structured content, and statistics
        """
        content_data = {
            'text': '',
            'structured': {
                'sections': {},
                'paragraphs': [],
                'tables': [],
                'lists': []
            },
            'stats': {
                'paragraph_count': 0,
                'table_count': 0,
                'heading_count': 0,
                'list_item_count': 0
            }
        }
        
        current_section = None
        section_content = []
        
        for element in doc.element.body:
            if element.tag.endswith('p'):  # Paragraph
                try:
                    para = Paragraph(element, doc)
                    text = para.text.strip()
                    
                    if not text:
                        continue
                    
                    content_data['stats']['paragraph_count'] += 1
                    
                    # Check if this is a heading/section
                    section_match = self._identify_section(text)
                    
                    if section_match:
                        # Save previous section
                        if current_section and section_content:
                            content_data['structured']['sections'][current_section] = '\n'.join(section_content)
                        
                        # Start new section
                        current_section = section_match
                        section_content = []
                        content_data['stats']['heading_count'] += 1
                    else:
                        # Add to current section or general content
                        if current_section:
                            section_content.append(text)
                        
                        # Add to paragraph list
                        content_data['structured']['paragraphs'].append({
                            'text': text,
                            'section': current_section,
                            'style': para.style.name if para.style else 'Normal'
                        })
                    
                    # Add to main text content
                    content_data['text'] += text + '\n'
                    
                except Exception as e:
                    self.logger.debug(f"Error processing paragraph: {e}")
            
            elif element.tag.endswith('tbl'):  # Table
                try:
                    table = Table(element, doc)
                    table_text = self._extract_table_content(table)
                    if table_text:
                        content_data['text'] += table_text + '\n'
                        content_data['structured']['tables'].append(table_text)
                        content_data['stats']['table_count'] += 1
                except Exception as e:
                    self.logger.debug(f"Error processing table: {e}")
        
        # Save final section
        if current_section and section_content:
            content_data['structured']['sections'][current_section] = '\n'.join(section_content)
        
        # Clean up text
        content_data['text'] = self._clean_extracted_text(content_data['text'])
        
        return content_data
    
    def _identify_section(self, text: str) -> Optional[str]:
        """Identify if text is a section heading"""
        for section_name, pattern in self.section_patterns.items():
            if pattern.match(text.strip()):
                return section_name
        return None
    
    def _extract_table_content(self, table: Table) -> str:
        """Extract text content from table"""
        table_text = ""
        for row in table.rows:
            row_text = []
            for cell in row.cells:
                cell_text = cell.text.strip()
                if cell_text:
                    row_text.append(cell_text)
            if row_text:
                table_text += ' | '.join(row_text) + '\n'
        return table_text
    
    def _extract_content_metadata(self, content: str) -> Dict[str, Any]:
        """
        Extract meeting metadata from document content
        
        Args:
            content: Extracted document text
            
        Returns:
            Dictionary with content-based metadata
        """
        metadata = {
            'participants_mentioned': [],
            'key_topics': [],
            'meeting_type': None
        }
        
        # Extract names mentioned in content (people doing actions)
        name_patterns = [
            r'([A-Z][a-z]+\s+[A-Z][a-z]+)\s+(?:will|said|mentioned|discussed|presented)',
            r'([A-Z][a-z]+)\s+(?:will|said|mentioned|discussed|presented)',
        ]
        
        participants = set()
        for pattern in name_patterns:
            matches = re.findall(pattern, content, re.IGNORECASE)
            for match in matches:
                if isinstance(match, tuple):
                    match = match[0]
                if len(match.split()) <= 3:  # Reasonable name length
                    participants.add(match.strip())
        
        metadata['participants_mentioned'] = list(participants)
        
        # Identify meeting type
        if any(word in content.lower() for word in ['standup', 'daily', 'scrum']):
            metadata['meeting_type'] = 'standup'
        elif any(word in content.lower() for word in ['review', 'retrospective', 'retro']):
            metadata['meeting_type'] = 'review'
        elif any(word in content.lower() for word in ['planning', 'plan']):
            metadata['meeting_type'] = 'planning'
        elif any(word in content.lower() for word in ['intro', 'introduction']):
            metadata['meeting_type'] = 'introduction'
        
        return metadata
    
    def _clean_extracted_text(self, text: str) -> str:
        """Clean and normalize extracted text"""
        if not text:
            return ""
        
        # Normalize line endings
        text = text.replace('\r\n', '\n').replace('\r', '\n')
        
        # Remove excessive whitespace
        text = re.sub(r'\n{3,}', '\n\n', text)
        text = re.sub(r'[ \t]+', ' ', text)
        
        # Remove common document artifacts
        text = re.sub(r'\f', '', text)  # Form feed characters
        text = re.sub(r'\u00a0', ' ', text)  # Non-breaking spaces
        
        return text.strip()
    
    def _calculate_confidence_score(self, content_data: Dict, filename_meta: Dict, 
                                  content_meta: Dict) -> float:
        """
        Calculate confidence score for extraction quality
        
        Returns:
            Float between 0.0 and 1.0 indicating extraction confidence
        """
        confidence = 0.0
        
        # Base confidence for successful text extraction
        if content_data['text']:
            confidence += 0.3
        
        # Bonus for structured content
        if content_data['structured']['sections']:
            confidence += 0.2
        
        # Bonus for meeting metadata extraction
        if filename_meta.get('title'):
            confidence += 0.2
        
        if filename_meta.get('date'):
            confidence += 0.1
        
        # Bonus for content metadata
        if content_meta.get('participants_mentioned'):
            confidence += 0.1
        
        # Bonus for document structure
        if content_data['stats']['paragraph_count'] > 5:
            confidence += 0.1
        
        return min(1.0, confidence)
    
    def detect_meeting_notes_docx(self, directory: str) -> List[str]:
        """
        Detect Google Docs meeting notes .docx files in directory
        
        Args:
            directory: Directory path to scan
            
        Returns:
            List of .docx file paths that match meeting notes patterns
        """
        docx_files = []
        
        try:
            for filename in os.listdir(directory):
                if filename.lower().endswith('.docx'):
                    # Check if matches meeting notes patterns
                    for pattern in self.meeting_notes_patterns:
                        if pattern.match(filename):
                            file_path = os.path.join(directory, filename)
                            if os.path.isfile(file_path):
                                docx_files.append(file_path)
                                break
        
        except PermissionError:
            self.logger.warning(f"Permission denied scanning directory: {directory}")
        except Exception as e:
            self.logger.error(f"Error scanning directory {directory}: {e}")
        
        return sorted(docx_files)
    
    def get_processing_stats(self) -> Dict[str, Any]:
        """Get processing statistics"""
        return self.stats.copy()


# Utility functions
def is_meeting_notes_docx(filename: str) -> bool:
    """Check if filename matches meeting notes pattern"""
    extractor = DocxContentExtractor()
    for pattern in extractor.meeting_notes_patterns:
        if pattern.match(filename):
            return True
    return False


# Standalone execution for testing
if __name__ == "__main__":
    import sys
    
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    extractor = DocxContentExtractor()
    
    if len(sys.argv) > 1:
        # Process specific file
        file_path = sys.argv[1]
        if os.path.exists(file_path):
            try:
                extracted_doc = extractor.extract_content(file_path)
                print(f"Successfully extracted content:")
                print(f"  Title: {extracted_doc.title}")
                print(f"  Meeting Date: {extracted_doc.meeting_metadata.get('date')}")
                print(f"  Participants: {extracted_doc.meeting_metadata.get('participants', [])}")
                print(f"  Confidence: {extracted_doc.confidence_score:.2f}")
                print(f"  Content length: {len(extracted_doc.content)} characters")
                print(f"  Sections: {list(extracted_doc.structured_content['sections'].keys())}")
                print(f"  Content preview: {extracted_doc.content[:300]}...")
            except Exception as e:
                print(f"Error extracting content: {e}")
        else:
            print(f"File not found: {file_path}")
    else:
        # Scan current directory
        current_dir = os.getcwd()
        files = extractor.detect_meeting_notes_docx(current_dir)
        print(f"Found {len(files)} meeting notes .docx files:")
        for file_path in files:
            print(f"  - {os.path.basename(file_path)}")